# -*- coding: utf-8 -*-
"""redes_comunidades.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oFo-pqHFThbZMjMgY_a8W_d_2xN7U6ja
"""

pip install python-louvain

import networkx as nx
import matplotlib.pyplot as plt
import random
import numpy as np
from collections import Counter

try:
    import community as community_louvain  # pip install python-louvain
except:
    community_louvain = None

def rede_comunidades(n=100, c=4, p_in=0.4, p_out=0.02, plot=True):
    """
    Gera uma rede com estrutura comunitária e calcula métricas estruturais.
    """
    G = nx.Graph()
    G.add_nodes_from(range(n))

    # define as comunidades
    tamanho = n // c
    comunidade = {i: i // tamanho for i in range(n)}

    # cria as arestas
    for i in range(n):
        for j in range(i + 1, n):
            if comunidade[i] == comunidade[j]:
                if random.random() < p_in:
                    G.add_edge(i, j)
            else:
                if random.random() < p_out:
                    G.add_edge(i, j)

    # visualização
    if plot:
        cores = [comunidade[n] for n in G.nodes]
        nx.draw(
            G,
            node_color=cores,
            cmap=plt.cm.Set3,
            with_labels=False,
            node_size=80,
            edge_color='gray'
        )
        plt.title(f"Rede com comunidades (n={n}, c={c}, p_in={p_in}, p_out={p_out})")
        plt.show()

    # métricas básicas
    graus = [grau for _, grau in G.degree()]
    print(f"Número de nós: {G.number_of_nodes()}")
    print(f"Número de arestas: {G.number_of_edges()}")
    print(f"Número de componentes conexas: {nx.number_connected_components(G)}")

    if nx.is_connected(G):
        print(f"Diâmetro: {nx.diameter(G)}")
        print(f"Caminho médio: {nx.average_shortest_path_length(G):.2f}")
    else:
        maior_componente = max(nx.connected_components(G), key=len)
        Gc = G.subgraph(maior_componente)
        print(f"Caminho médio (maior componente): {nx.average_shortest_path_length(Gc):.2f}")
        print(f"Diâmetro (maior componente): {nx.diameter(Gc)}")
        print(f"Tamanho do maior componente: {len(maior_componente)}")

    print(f"Grau médio: {np.mean(graus):.2f}")
    print(f"Desvio padrão dos graus: {np.std(graus):.2f}")
    print(f"Coeficiente de clustering médio: {nx.average_clustering(G):.2f}")
    print(f"Densidade: {nx.density(G):.4f}")

    # Modularidade com Louvain
    if community_louvain is not None:
        partition = community_louvain.best_partition(G)
        modularidade = community_louvain.modularity(partition, G)
        print(f"Modularidade (Louvain): {modularidade:.2f}")
    else:
        print("Biblioteca 'python-louvain' não instalada – modularidade não calculada.")

    # Histograma dos graus
    if plot:
        plt.hist(
            graus,
            bins=range(min(graus), max(graus) + 2),
            align='left',
            color='skyblue',
            edgecolor='black'
        )
        plt.title("Distribuição de graus — Rede com comunidades")
        plt.xlabel("Grau")
        plt.ylabel("Número de nós")
        plt.grid(True)
        plt.show()

    return G, comunidade