# -*- coding: utf-8 -*-
"""redes_comunidades.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oFo-pqHFThbZMjMgY_a8W_d_2xN7U6ja
"""

import networkx as nx
import matplotlib.pyplot as plt
import random
import numpy as np

def rede_comunidades(n=100, c=4, p_in=0.4, p_out=0.02):
    """
    rede com comunidades:
    - p_in: probabilidade de conexão dentro da comunidade
    - p_out: probabilidade de conexão entre comunidades
    """
    G = nx.Graph()
    G.add_nodes_from(range(n))

    # define as comunidades
    tamanho = n // c
    comunidade = {i: i // tamanho for i in range(n)}

    # cria as arestas
    for i in range(n):
        for j in range(i + 1, n):
            if comunidade[i] == comunidade[j]:
                if random.random() < p_in:
                    G.add_edge(i, j)
            else:
                if random.random() < p_out:
                    G.add_edge(i, j)

    # visualização
    cores = [comunidade[n] for n in G.nodes]
    nx.draw(
        G,
        node_color=cores,
        cmap=plt.cm.Set3,
        with_labels=True,
        node_size=80,
        font_size=6,
        edge_color='gray'
    )
    plt.title(f"Rede com comunidades (n={n}, c={c}, p_in={p_in}, p_out={p_out})")
    plt.show()

    # métricas
    graus = [grau for _, grau in G.degree()]

    print(f"Número de componentes conexas: {nx.number_connected_components(G)}")
    if nx.is_connected(G):
        print(f"Diâmetro: {nx.diameter(G)}")
        print(f"Caminho médio: {nx.average_shortest_path_length(G):.2f}")
    else:
        print("Atenção: Grafo desconexo – não é possível calcular caminho médio e diâmetro.")

    print(f"Grau médio: {np.mean(graus):.2f}")
    print(f"Desvio padrão dos graus: {np.std(graus):.2f}")
    print(f"Coeficiente de clustering médio: {nx.average_clustering(G):.2f}")
    print(f"Densidade: {nx.density(G):.2f}")

    # histograma
    plt.hist(
        graus,
        bins=range(min(graus), max(graus) + 2),
        align='left',
        color='skyblue',
        edgecolor='black'
    )
    plt.title(f"Distribuição de graus — Rede com comunidades")
    plt.xlabel("Grau")
    plt.ylabel("Número de nós")
    plt.grid(True)
    plt.show()

    return G, comunidade

G, comunidade = rede_comunidades(n=100, c=4, p_in=0.4, p_out=0.02)